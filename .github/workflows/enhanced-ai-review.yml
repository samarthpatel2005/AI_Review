name: AI Code Review (Enhanced)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, master, develop ]

env:
  AWS_DEFAULT_REGION: us-east-1

jobs:
  enhanced-ai-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install boto3 requests python-dotenv

    - name: Create Enhanced AI Reviewer
      run: |
        cat > enhanced_reviewer.py << 'EOF'
        #!/usr/bin/env python3
        """
        Enhanced GitHub Action PR Reviewer with inline comments
        Works like GitHub Copilot
        """
        import json
        import os
        import sys
        import requests
        import boto3
        import re
        from typing import List, Dict, Optional

        class GitHubActionEnhancedReviewer:
            def __init__(self):
                self.github_token = os.environ.get('GITHUB_TOKEN')
                self.aws_access_key = os.environ.get('AWS_ACCESS_KEY_ID')
                self.aws_secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY')
                self.region = os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
                self.model_id = os.environ.get('BEDROCK_MODEL_ID', 'amazon.nova-micro-v1:0')
                
                if not all([self.github_token, self.aws_access_key, self.aws_secret_key]):
                    print("‚ùå Missing required environment variables!")
                    sys.exit(1)
                
                # Initialize Bedrock client
                self.bedrock = boto3.client(
                    'bedrock-runtime',
                    region_name=self.region,
                    aws_access_key_id=self.aws_access_key,
                    aws_secret_access_key=self.aws_secret_key
                )
                
                self.headers = {
                    'Authorization': f'token {self.github_token}',
                    'Accept': 'application/vnd.github.v3+json',
                    'User-Agent': 'Enhanced-AI-Code-Reviewer'
                }

            def get_pr_files(self, repo: str, pr_number: int) -> List[Dict]:
                """Get list of files changed in the PR."""
                try:
                    url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/files"
                    response = requests.get(url, headers=self.headers, timeout=30)
                    response.raise_for_status()
                    
                    files_data = response.json()
                    
                    # Filter code files
                    code_extensions = {'.py', '.js', '.ts', '.java', '.c', '.cpp', '.h', '.hpp', '.go', '.rs', '.php', '.rb', '.swift', '.kt', '.cs', '.scala', '.sh', '.yml', '.yaml', '.json'}
                    
                    code_files = []
                    for file_data in files_data:
                        filename = file_data.get('filename', '')
                        if any(filename.endswith(ext) for ext in code_extensions):
                            code_files.append({
                                'filename': filename,
                                'status': file_data.get('status', ''),
                                'patch': file_data.get('patch', ''),
                                'additions': file_data.get('additions', 0),
                                'deletions': file_data.get('deletions', 0)
                            })
                    
                    return code_files
                except Exception as e:
                    print(f"‚ùå Error fetching PR files: {e}")
                    return []

            def parse_diff_lines(self, patch: str) -> List[Dict]:
                """Parse diff to extract added lines with line numbers."""
                lines = patch.split('\n')
                changes = []
                new_line = 0
                
                for line in lines:
                    if line.startswith('@@'):
                        # Parse hunk header
                        hunk_match = re.match(r'@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@', line)
                        if hunk_match:
                            new_line = int(hunk_match.group(1)) - 1
                    elif line.startswith('+') and not line.startswith('+++'):
                        new_line += 1
                        changes.append({
                            'line_number': new_line,
                            'content': line[1:],  # Remove +
                            'full_line': line
                        })
                    elif line.startswith(' '):
                        new_line += 1
                
                return changes

            def analyze_file_with_ai(self, filename: str, patch: str) -> List[Dict]:
                """Analyze a file with AI and return inline comments."""
                added_lines = self.parse_diff_lines(patch)
                if not added_lines:
                    return []
                
                # Create focused prompt
                lines_text = '\n'.join([f"Line {line['line_number']}: {line['content']}" for line in added_lines[:15]])
                
                prompt = f"""Analyze this code change in file: {filename}

        DIFF PATCH:
        ```diff
        {patch[:3000]}
        ```

        ADDED LINES TO REVIEW:
        {lines_text}

        Provide ONLY critical issues as JSON:
        {{
          "comments": [
            {{
              "line": <line_number>,
              "severity": "critical|high|medium|suggestion",
              "type": "security|bug|performance|style",
              "message": "Brief issue description",
              "suggestion": "How to fix it",
              "suggested_code": "EXACT single line replacement"
            }}
          ]
        }}

        IMPORTANT: For "suggested_code", provide ONLY the exact replacement for that specific line.
        Do NOT include surrounding context - just the fixed line.

        Examples:
        - If line is: password = "hardcoded123"
        - suggested_code: password = os.environ.get('PASSWORD')

        - If line is: return a / b
        - suggested_code: return a / b if b != 0 else 0

        Focus ONLY on:
        - Security vulnerabilities
        - Logic errors and bugs
        - Performance issues
        - Critical style problems

        Skip minor style issues. Only flag real problems."""
                
                try:
                    body = {
                        "messages": [{"role": "user", "content": [{"text": prompt}]}],
                        "inferenceConfig": {"maxTokens": 1500, "temperature": 0.1, "topP": 0.8}
                    }
                    
                    response = self.bedrock.invoke_model(
                        modelId=self.model_id,
                        body=json.dumps(body),
                        contentType="application/json",
                        accept="application/json"
                    )
                    
                    result = json.loads(response['body'].read())
                    ai_response = result['output']['message']['content'][0]['text']
                    
                    return self.parse_ai_response(ai_response, filename, added_lines)
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Error analyzing {filename}: {e}")
                    return []

            def parse_ai_response(self, response: str, filename: str, added_lines: List[Dict]) -> List[Dict]:
                """Parse AI response and create review comments with GitHub suggestions."""
                comments = []
                
                try:
                    # Extract JSON from response
                    json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
                    if not json_match:
                        json_match = re.search(r'\{.*\}', response, re.DOTALL)
                    
                    if not json_match:
                        return comments
                    
                    data = json.loads(json_match.group(1) if json_match.groups() else json_match.group(0))
                    
                    for comment_data in data.get('comments', []):
                        line_num = comment_data.get('line')
                        severity = comment_data.get('severity', 'medium')
                        
                        # Find matching line in our added lines
                        matching_line = next((line for line in added_lines if line['line_number'] == line_num), None)
                        
                        if matching_line:
                            # Create severity emoji and comment
                            severity_emoji = {
                                'critical': 'üî¥',
                                'high': 'üü†', 
                                'medium': 'üü°',
                                'low': 'üîµ',
                                'suggestion': 'üí°'
                            }.get(severity, 'üí¨')
                            
                            issue_type = comment_data.get('type', 'general').upper()
                            message = comment_data.get('message', '')
                            suggestion = comment_data.get('suggestion', '')
                            suggested_code = comment_data.get('suggested_code', '')
                            
                            # Build comment body with GitHub suggestion format
                            comment_body = f"{severity_emoji} **{severity.upper()} - {issue_type}**\\n\\n{message}"
                            
                            if suggestion:
                                comment_body += f"\\n\\n**üí° Suggestion:** {suggestion}"
                            
                            # Use GitHub's suggestion format for commit suggestions
                            if suggested_code:
                                comment_body += f"\\n\\n**üîß Suggested change:**\\n```suggestion\\n{suggested_code}\\n```"
                            
                            comments.append({
                                'path': filename,
                                'line': line_num,
                                'body': comment_body,
                                'severity': severity
                            })
                
                except Exception as e:
                    print(f"‚ö†Ô∏è Error parsing AI response for {filename}: {e}")
                
                return comments

            def post_review_with_comments(self, repo: str, pr_number: int, commit_sha: str, all_comments: List[Dict]):
                """Post a review with inline comments."""
                try:
                    url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/reviews"
                    
                    # Create summary
                    if not all_comments:
                        # No issues found
                        review_data = {
                            'commit_id': commit_sha,
                            'body': """## ü§ñ AI Code Review Result

        ‚úÖ **No issues found!**

        The AI reviewer analyzed your code changes and didn't detect any obvious problems. The changes look good to merge! üéâ

        ---
        *Powered by AWS Bedrock AI* ‚ö°""",
                            'event': 'COMMENT'
                        }
                    else:
                        # Issues found - create summary
                        severity_counts = {}
                        for comment in all_comments:
                            sev = comment['severity']
                            severity_counts[sev] = severity_counts.get(sev, 0) + 1
                        
                        summary = "## ü§ñ AI Code Review Summary\\n\\n**Issues found:**\\n"
                        for severity, count in severity_counts.items():
                            emoji = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üîµ', 'suggestion': 'üí°'}.get(severity, 'üí¨')
                            summary += f"- {emoji} {severity.title()}: {count}\\n"
                        
                        summary += f"\\n**Total issues:** {len(all_comments)}\\n\\n"
                        summary += "Please review the inline comments for detailed feedback and suggestions.\\n\\n"
                        summary += "---\\n*Powered by AWS Bedrock AI* ‚ö°"
                        
                        # Determine review event
                        has_critical = any(c['severity'] == 'critical' for c in all_comments)
                        has_high = any(c['severity'] == 'high' for c in all_comments)
                        
                        event = "REQUEST_CHANGES" if (has_critical or has_high) else "COMMENT"
                        
                        review_data = {
                            'commit_id': commit_sha,
                            'body': summary,
                            'event': event,
                            'comments': all_comments
                        }
                    
                    response = requests.post(url, headers=self.headers, json=review_data, timeout=30)
                    response.raise_for_status()
                    
                    print(f"‚úÖ Posted review with {len(all_comments)} inline comments")
                    
                except Exception as e:
                    print(f"‚ùå Error posting review: {e}")

            def review_pr(self, repo: str, pr_number: int):
                """Main review function."""
                print(f"üîç Starting enhanced review of PR #{pr_number} in {repo}")
                
                # Get PR info for commit SHA
                pr_url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}"
                pr_response = requests.get(pr_url, headers=self.headers)
                pr_response.raise_for_status()
                pr_data = pr_response.json()
                commit_sha = pr_data['head']['sha']
                
                # Get changed files
                files = self.get_pr_files(repo, pr_number)
                
                if not files:
                    print("‚ÑπÔ∏è No code files to review")
                    return
                
                print(f"üìÅ Analyzing {len(files)} code files...")
                
                # Analyze all files
                all_comments = []
                for file_data in files:
                    filename = file_data['filename']
                    patch = file_data['patch']
                    
                    if patch.strip():
                        print(f"üîç Reviewing {filename}...")
                        file_comments = self.analyze_file_with_ai(filename, patch)
                        all_comments.extend(file_comments)
                
                # Post review
                self.post_review_with_comments(repo, pr_number, commit_sha, all_comments)
                
                if all_comments:
                    print(f"üìù Found {len(all_comments)} issues to review")
                else:
                    print("‚úÖ No issues found - code looks good!")

        if __name__ == "__main__":
            try:
                reviewer = GitHubActionEnhancedReviewer()
                
                # Get event data
                event_path = os.environ.get('GITHUB_EVENT_PATH')
                if event_path and os.path.exists(event_path):
                    with open(event_path, 'r') as f:
                        event_data = json.load(f)
                    
                    repo = event_data['repository']['full_name']
                    pr_number = event_data['pull_request']['number']
                    
                    reviewer.review_pr(repo, pr_number)
                else:
                    print("‚ùå No GitHub event data found")
                    sys.exit(1)
                    
            except Exception as e:
                print(f"‚ùå Review failed: {e}")
                sys.exit(1)
        EOF

    - name: Run Enhanced AI Code Review
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        BEDROCK_MODEL_ID: amazon.nova-micro-v1:0
        GITHUB_EVENT_PATH: ${{ github.event_path }}
      run: |
        python enhanced_reviewer.py

    - name: Comment on Success
      if: success()
      run: |
        echo "‚úÖ Enhanced AI code review completed successfully!"
        echo "üí¨ Check the PR for inline comments and suggestions!"
        
    - name: Comment on Failure
      if: failure()
      run: |
        echo "‚ùå Enhanced AI code review failed!"
        echo "Please check the logs for details."