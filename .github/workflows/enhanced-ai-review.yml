name: AI Code Review (Enhanced)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, master, develop ]

env:
  AWS_DEFAULT_REGION: us-east-1

jobs:
  enhanced-ai-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install boto3 requests python-dotenv

    - name: Create Enhanced AI Reviewer
      run: |
        cat > enhanced_reviewer.py << 'EOF'
        #!/usr/bin/env python3
        """
        Enhanced GitHub Action PR Reviewer with inline comments
        Works like GitHub Copilot
        """
        import json
        import os
        import sys
        import requests
        import boto3
        import re
        from typing import List, Dict, Optional

        class GitHubActionEnhancedReviewer:
            def __init__(self):
                self.github_token = os.environ.get('GITHUB_TOKEN')
                self.aws_access_key = os.environ.get('AWS_ACCESS_KEY_ID')
                self.aws_secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY')
                self.region = os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
                self.model_id = os.environ.get('BEDROCK_MODEL_ID', 'amazon.nova-micro-v1:0')
                
                if not all([self.github_token, self.aws_access_key, self.aws_secret_key]):
                    print("‚ùå Missing required environment variables!")
                    sys.exit(1)
                
                # Initialize Bedrock client
                self.bedrock = boto3.client(
                    'bedrock-runtime',
                    region_name=self.region,
                    aws_access_key_id=self.aws_access_key,
                    aws_secret_access_key=self.aws_secret_key
                )
                
                self.headers = {
                    'Authorization': f'token {self.github_token}',
                    'Accept': 'application/vnd.github.v3+json',
                    'User-Agent': 'Enhanced-AI-Code-Reviewer'
                }

            def get_pr_files(self, repo: str, pr_number: int) -> List[Dict]:
                """Get list of files changed in the PR."""
                try:
                    url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/files"
                    response = requests.get(url, headers=self.headers, timeout=30)
                    response.raise_for_status()
                    
                    files_data = response.json()
                    
                    # Filter code files
                    code_extensions = {'.py', '.js', '.ts', '.java', '.c', '.cpp', '.h', '.hpp', '.go', '.rs', '.php', '.rb', '.swift', '.kt', '.cs', '.scala', '.sh', '.yml', '.yaml', '.json'}
                    
                    code_files = []
                    for file_data in files_data:
                        filename = file_data.get('filename', '')
                        if any(filename.endswith(ext) for ext in code_extensions):
                            code_files.append({
                                'filename': filename,
                                'status': file_data.get('status', ''),
                                'patch': file_data.get('patch', ''),
                                'additions': file_data.get('additions', 0),
                                'deletions': file_data.get('deletions', 0)
                            })
                    
                    return code_files
                except Exception as e:
                    print(f"‚ùå Error fetching PR files: {e}")
                    return []

            def parse_diff_lines(self, patch: str) -> List[Dict]:
                """Parse diff to extract added lines with line numbers."""
                lines = patch.split('\n')
                changes = []
                new_line = 0
                
                for line in lines:
                    if line.startswith('@@'):
                        # Parse hunk header
                        hunk_match = re.match(r'@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@', line)
                        if hunk_match:
                            new_line = int(hunk_match.group(1)) - 1
                    elif line.startswith('+') and not line.startswith('+++'):
                        new_line += 1
                        changes.append({
                            'line_number': new_line,
                            'content': line[1:],  # Remove +
                            'full_line': line
                        })
                    elif line.startswith(' '):
                        new_line += 1
                
                return changes

            def analyze_file_with_ai(self, filename: str, patch: str) -> List[Dict]:
                """Analyze a file with AI and return inline comments."""
                added_lines = self.parse_diff_lines(patch)
                if not added_lines:
                    return []
                
                # Create focused prompt
                lines_text = '\n'.join([f"Line {line['line_number']}: {line['content']}" for line in added_lines[:15]])
                
                prompt = f"""Analyze this code change in file: {filename}

        DIFF PATCH:
        ```diff
        {patch[:3000]}
        ```

        ADDED LINES TO REVIEW:
        {lines_text}

        Provide analysis as JSON:
        {{
          "comments": [
            {{
              "line": <line_number>,
              "message": "Brief, clear description like GitHub Copilot",
              "suggested_code": "EXACT single line replacement"
            }}
          ]
        }}

        SPECIFIC ISSUES TO CHECK:
        1. **Comment formatting**: Comments like "#For test" should be "# For test" (space after #)
        2. **Test/debug comments**: Comments like "# hello test" or "# test" should be removed in production
        3. **Hardcoded credentials**: Any passwords, API keys, or secrets in code
        4. **Missing error handling**: Division by zero, null checks, etc.
        5. **Security issues**: SQL injection, command injection, etc.

        RULES:
        1. Write simple, clear messages like GitHub Copilot
        2. For "suggested_code", provide ONLY the exact replacement line
        3. ALWAYS flag comment formatting issues (missing space after #)
        4. ALWAYS flag test/debug comments that should be removed
        5. Keep messages short and clear

        Example responses:
        - For "#For test" ‚Üí message: "The comment lacks proper spacing. It should be '# For test' with a space after the hash symbol to follow Python commenting conventions.", suggested_code: "# For test"
        - For "# hello test" ‚Üí message: "This test comment should be removed before merging to production as it appears to be temporary debugging or testing code.", suggested_code: ""

        Focus on real issues that developers should fix before merging."""
                
                try:
                    body = {
                        "messages": [{"role": "user", "content": [{"text": prompt}]}],
                        "inferenceConfig": {"maxTokens": 1500, "temperature": 0.1, "topP": 0.8}
                    }
                    
                    response = self.bedrock.invoke_model(
                        modelId=self.model_id,
                        body=json.dumps(body),
                        contentType="application/json",
                        accept="application/json"
                    )
                    
                    result = json.loads(response['body'].read())
                    ai_response = result['output']['message']['content'][0]['text']
                    
                    return self.parse_ai_response(ai_response, filename, added_lines)
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Error analyzing {filename}: {e}")
                    return []

            def parse_ai_response(self, response: str, filename: str, added_lines: List[Dict]) -> List[Dict]:
                """Parse AI response and create simple review comments like GitHub Copilot."""
                comments = []
                
                try:
                    # Extract JSON from response
                    json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
                    if not json_match:
                        json_match = re.search(r'\{.*\}', response, re.DOTALL)
                    
                    if not json_match:
                        return comments
                    
                    data = json.loads(json_match.group(1) if json_match.groups() else json_match.group(0))
                    
                    for comment_data in data.get('comments', []):
                        line_num = comment_data.get('line')
                        message = comment_data.get('message', '')
                        suggested_code = comment_data.get('suggested_code', '')
                        
                        # Find matching line in our added lines
                        matching_line = next((line for line in added_lines if line['line_number'] == line_num), None)
                        
                        if matching_line:
                            # Build simple comment body like GitHub Copilot
                            comment_body = message
                            
                            # Use GitHub's suggestion format for commit suggestions
                            if suggested_code:
                                comment_body += f"\\n\\n**Suggested change**\\n```suggestion\\n{suggested_code}\\n```"
                            
                            comments.append({
                                'path': filename,
                                'line': line_num,
                                'body': comment_body,
                                'severity': 'suggestion'
                            })
                
                except Exception as e:
                    print(f"‚ö†Ô∏è Error parsing AI response for {filename}: {e}")
                
                return comments

            def post_review_with_comments(self, repo: str, pr_number: int, commit_sha: str, all_comments: List[Dict]):
                """Post a review with ONLY inline comments - no summary."""
                try:
                    url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/reviews"
                    
                    if not all_comments:
                        # No issues found - post simple comment
                        comment_url = f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments"
                        simple_comment = {"body": "‚úÖ No issues found! Code looks good to merge."}
                        requests.post(comment_url, headers=self.headers, json=simple_comment, timeout=30)
                        print("‚úÖ Posted simple approval")
                    else:
                        # Post ONLY inline comments without any summary
                        review_data = {
                            'commit_id': commit_sha,
                            'event': 'COMMENT',  # Always use COMMENT
                            'comments': all_comments
                        }
                        
                        response = requests.post(url, headers=self.headers, json=review_data, timeout=30)
                        response.raise_for_status()
                        
                        print(f"‚úÖ Posted {len(all_comments)} inline suggestions only")
                    
                except Exception as e:
                    print(f"‚ùå Error posting review: {e}")

            def review_pr(self, repo: str, pr_number: int):
                """Main review function."""
                print(f"üîç Starting enhanced review of PR #{pr_number} in {repo}")
                
                try:
                    # Get PR info for commit SHA
                    pr_url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}"
                    pr_response = requests.get(pr_url, headers=self.headers)
                    pr_response.raise_for_status()
                    pr_data = pr_response.json()
                    commit_sha = pr_data['head']['sha']
                    
                    print(f"üìä PR info: {pr_data['title']}")
                    print(f"üìä Commit SHA: {commit_sha}")
                    
                    # Get changed files
                    files = self.get_pr_files(repo, pr_number)
                    
                    if not files:
                        print("‚ÑπÔ∏è No code files to review")
                        return
                    
                    print(f"üìÅ Analyzing {len(files)} code files...")
                    for file_data in files:
                        print(f"  - {file_data['filename']} ({file_data['additions']} additions)")
                    
                    # Analyze all files
                    all_comments = []
                    for file_data in files:
                        filename = file_data['filename']
                        patch = file_data['patch']
                        
                        if patch.strip():
                            print(f"üîç Reviewing {filename}...")
                            print(f"üìù Patch preview: {patch[:200]}...")
                            
                            file_comments = self.analyze_file_with_ai(filename, patch)
                            print(f"üí¨ Generated {len(file_comments)} comments for {filename}")
                            all_comments.extend(file_comments)
                    
                    # Post review
                    print(f"üì§ Posting {len(all_comments)} total comments...")
                    self.post_review_with_comments(repo, pr_number, commit_sha, all_comments)
                    
                    if all_comments:
                        print(f"üìù Found {len(all_comments)} issues to review")
                    else:
                        print("‚úÖ No issues found - code looks good!")
                        
                except Exception as e:
                    print(f"‚ùå Error in review_pr: {e}")
                    import traceback
                    traceback.print_exc()
                    raise

        if __name__ == "__main__":
            try:
                reviewer = GitHubActionEnhancedReviewer()
                
                # Get event data
                event_path = os.environ.get('GITHUB_EVENT_PATH')
                if event_path and os.path.exists(event_path):
                    with open(event_path, 'r') as f:
                        event_data = json.load(f)
                    
                    repo = event_data['repository']['full_name']
                    pr_number = event_data['pull_request']['number']
                    
                    reviewer.review_pr(repo, pr_number)
                else:
                    print("‚ùå No GitHub event data found")
                    sys.exit(1)
                    
            except Exception as e:
                print(f"‚ùå Review failed: {e}")
                sys.exit(1)
        EOF

    - name: Debug GitHub Event
      run: |
        echo "=== GitHub Event Debug ==="
        echo "Event name: ${{ github.event_name }}"
        echo "Action: ${{ github.event.action }}"
        echo "PR number: ${{ github.event.pull_request.number }}"
        echo "Repository: ${{ github.repository }}"
        echo "==========================="

    - name: Run Enhanced AI Code Review
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        BEDROCK_MODEL_ID: amazon.nova-micro-v1:0
        GITHUB_EVENT_PATH: ${{ github.event_path }}
      run: |
        python enhanced_reviewer.py

    - name: Comment on Success
      if: success()
      run: |
        echo "‚úÖ Enhanced AI code review completed successfully!"
        echo "üí¨ Check the PR for inline comments and suggestions!"
        
    - name: Comment on Failure
      if: failure()
      run: |
        echo "‚ùå Enhanced AI code review failed!"
        echo "Please check the logs for details."