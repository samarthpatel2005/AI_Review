# ðŸ¤– Enhanced AI PR Review (GitHub Copilot Style)
# 
# SETUP REQUIRED:
# 1. Add these GitHub Secrets in Settings â†’ Secrets and variables â†’ Actions:
#    - AWS_ACCESS_KEY_ID: Your AWS access key
#    - AWS_SECRET_ACCESS_KEY: Your AWS secret key
# 2. Enable amazon.nova-micro-v1:0 model in AWS Bedrock console
# 3. Ensure AWS region is set correctly below (default: us-east-1)
#
# CUSTOMIZATION:
# - Change AI model: Edit line ~175 (modelId)
# - Add languages: Edit file extensions in detection logic
# - Adjust patterns: Modify detection rules starting line ~200
# - Change prompts: Edit AI prompts around line ~160

name: Enhanced AI PR Review (Copilot Style)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, master, develop ]  # Customize target branches

env:
  AWS_DEFAULT_REGION: us-east-1  # Change to your AWS region if needed

jobs:
  ai-pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install boto3 requests

    - name: Run Enhanced PR Review
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        python3 << 'EOF'
        import os, sys, json, requests, boto3, re
        from datetime import datetime

        print("ðŸ¤– Enhanced AI PR Review (Copilot Style)")
        
        # Get environment
        github_token = os.environ.get('GITHUB_TOKEN')
        repo = os.environ.get('GITHUB_REPOSITORY') 
        pr_number = os.environ.get('PR_NUMBER')
        aws_key = os.environ.get('AWS_ACCESS_KEY_ID')
        aws_secret = os.environ.get('AWS_SECRET_ACCESS_KEY')

        # Initialize Bedrock
        bedrock = None
        try:
            bedrock = boto3.client('bedrock-runtime', region_name='us-east-1', 
                                 aws_access_key_id=aws_key, aws_secret_access_key=aws_secret)
            print("âœ… Bedrock client initialized")
        except Exception as e:
            print(f"âš ï¸ Bedrock error: {e}")

        # GitHub API headers
        headers = {'Authorization': f'token {github_token}', 'Accept': 'application/vnd.github.v3+json'}

        try:
            # Get PR data
            pr_response = requests.get(f"https://api.github.com/repos/{repo}/pulls/{pr_number}", headers=headers)
            pr_response.raise_for_status()
            pr_data = pr_response.json()
            
            files_response = requests.get(f"https://api.github.com/repos/{repo}/pulls/{pr_number}/files", headers=headers)
            files_response.raise_for_status()
            files_data = files_response.json()
            
            print(f"ðŸ“‹ Analyzing PR #{pr_number} with {len(files_data)} files")
            
            # Create PR overview
            title = pr_data.get('title', 'No title')
            total_files = len(files_data)
            total_additions = sum(f.get('additions', 0) for f in files_data)
            total_deletions = sum(f.get('deletions', 0) for f in files_data)
            
            overview_parts = [
                "## Pull Request Overview",
                "",
                f"This PR modifies {total_files} file{'s' if total_files != 1 else ''} with {total_additions} additions and {total_deletions} deletions.",
                "",
                f"**{title}**",
                "",
                "### Changes Summary"
            ]
            
            # Add file changes
            for file_data in files_data:
                filename = file_data.get('filename', '')
                additions = file_data.get('additions', 0)
                deletions = file_data.get('deletions', 0)
                status = file_data.get('status', '')
                
                if status == 'added':
                    overview_parts.append(f"â€¢ **Added** `{filename}` ({additions} lines)")
                elif status == 'modified':
                    overview_parts.append(f"â€¢ **Modified** `{filename}` (+{additions}/-{deletions})")
                else:
                    overview_parts.append(f"â€¢ **Changed** `{filename}`")
            
            # Add code diff
            overview_parts.extend(["", "### Code Changes"])
            for file_data in files_data:
                filename = file_data.get('filename', '')
                patch = file_data.get('patch', '')
                if patch:
                    overview_parts.extend([f"", f"**{filename}**", "```diff"])
                    for line in patch.split('\n'):
                        if not line.startswith('@@') and not line.startswith('+++') and not line.startswith('---'):
                            if line.startswith(('+', '-', ' ')):
                                overview_parts.append(line)
                    overview_parts.append("```")
            
            # Add Copilot tip
            overview_parts.extend([
                "",
                "---", 
                "**Tip:** Customize your code reviews with copilot-instructions.md. [Create the file](https://github.com/github/copilot-instructions) or [learn how to get started](https://docs.github.com/en/copilot)."
            ])
            
            # Post overview
            overview_text = "\n".join(overview_parts)
            comment_response = requests.post(
                f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments",
                headers=headers,
                json={'body': overview_text}
            )
            
            if comment_response.status_code == 201:
                print("âœ… Posted PR overview")
            else:
                print(f"âš ï¸ Failed to post overview: {comment_response.status_code}")
            
            # Enhanced AI Analysis for ALL issues and file types
            if bedrock:
                commit_sha = pr_data['head']['sha']
                review_comments = []
                
                for file_data in files_data:
                    filename = file_data.get('filename', '')
                    patch = file_data.get('patch', '')
                    status = file_data.get('status', '')
                    
                    # Skip binary files
                    skip_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.zip', '.exe', '.dll']
                    if not patch or any(filename.lower().endswith(ext) for ext in skip_extensions):
                        continue
                    
                    print(f"ðŸ” AI analyzing {filename} (status: {status})...")
                    
                    # UNIVERSAL AI prompt for ALL programming languages and issues
                    file_ext = filename.split('.')[-1].lower() if '.' in filename else ''
                    
                    # Comprehensive language-specific analysis
                    if file_ext in ['c', 'cpp', 'cc', 'cxx', 'h', 'hpp']:
                        prompt = "Analyze this C/C++ code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Buffer overflows (gets, strcpy, strcat, sprintf, scanf), " + \
                                 "hardcoded secrets, format string vulnerabilities, integer overflows\n" + \
                                 "âš ï¸ MEMORY: Memory leaks (malloc/new without free/delete), double free, " + \
                                 "use after free, uninitialized variables, null pointer dereference\n" + \
                                 "ðŸ’¡ QUALITY: Division by zero, infinite loops, dead code, test comments\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['py', 'pyw']:
                        prompt = "Analyze this Python code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, SQL injection, command injection, " + \
                                 "eval/exec usage, pickle vulnerabilities, path traversal\n" + \
                                 "âš ï¸ QUALITY: Exception handling, resource leaks, performance issues, " + \
                                 "unused imports, mutable defaults, global variables\n" + \
                                 "ðŸ’¡ STYLE: PEP8 violations, missing type hints, print statements, test comments\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['js', 'jsx', 'ts', 'tsx']:
                        prompt = "Analyze this JavaScript/TypeScript code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: XSS vulnerabilities, prototype pollution, eval usage, " + \
                                 "hardcoded secrets, insecure randomness, CSRF vulnerabilities\n" + \
                                 "âš ï¸ QUALITY: Memory leaks, callback hell, promise rejections, " + \
                                 "var usage, == vs ===, missing error handling\n" + \
                                 "ðŸ’¡ STYLE: Console.log statements, unused variables, test comments, " + \
                                 "missing semicolons, arrow function usage\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['java', 'kt', 'scala']:
                        prompt = "Analyze this Java/Kotlin/Scala code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, SQL injection, deserialization vulnerabilities, " + \
                                 "path traversal, XML external entity (XXE)\n" + \
                                 "âš ï¸ QUALITY: Resource leaks (streams, connections), null pointer exceptions, " + \
                                 "infinite loops, thread safety issues, memory leaks\n" + \
                                 "ðŸ’¡ STYLE: System.out.println usage, unused imports, test comments, " + \
                                 "missing generics, raw types\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['go']:
                        prompt = "Analyze this Go code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, SQL injection, command injection, " + \
                                 "race conditions, unsafe package usage\n" + \
                                 "âš ï¸ QUALITY: Goroutine leaks, unchecked errors, resource leaks, " + \
                                 "panic usage, defer in loops\n" + \
                                 "ðŸ’¡ STYLE: fmt.Print statements, unused variables, test comments, " + \
                                 "gofmt violations, missing error handling\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['rs']:
                        prompt = "Analyze this Rust code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, unsafe blocks, integer overflows, " + \
                                 "buffer overflows in unsafe code\n" + \
                                 "âš ï¸ QUALITY: Unwrap usage, panic calls, unused variables, " + \
                                 "clone overuse, blocking in async\n" + \
                                 "ðŸ’¡ STYLE: println! statements, test comments, missing documentation, " + \
                                 "inefficient string handling\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['cs']:
                        prompt = "Analyze this C# code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, SQL injection, XSS, deserialization, " + \
                                 "path traversal, weak cryptography\n" + \
                                 "âš ï¸ QUALITY: Resource disposal (using statements), null reference exceptions, " + \
                                 "memory leaks, thread safety\n" + \
                                 "ðŸ’¡ STYLE: Console.WriteLine, unused usings, test comments, " + \
                                 "missing async/await, boxing\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['php']:
                        prompt = "Analyze this PHP code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: SQL injection, XSS, file inclusion, hardcoded secrets, " + \
                                 "command injection, session fixation\n" + \
                                 "âš ï¸ QUALITY: Error handling, resource leaks, performance issues, " + \
                                 "globals usage, magic numbers\n" + \
                                 "ðŸ’¡ STYLE: var_dump/print_r, test comments, deprecated functions, " + \
                                 "PSR violations, missing type declarations\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['rb']:
                        prompt = "Analyze this Ruby code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, SQL injection, command injection, " + \
                                 "eval usage, YAML.load vulnerabilities\n" + \
                                 "âš ï¸ QUALITY: Exception handling, performance issues, memory leaks, " + \
                                 "global variables, thread safety\n" + \
                                 "ðŸ’¡ STYLE: puts/p statements, test comments, unused variables, " + \
                                 "style guide violations\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['swift']:
                        prompt = "Analyze this Swift code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets, unsafe pointers, force unwrapping, " + \
                                 "weak cryptography, keychain issues\n" + \
                                 "âš ï¸ QUALITY: Memory leaks, retain cycles, force unwrapping, " + \
                                 "thread safety, performance issues\n" + \
                                 "ðŸ’¡ STYLE: print statements, test comments, force casts, " + \
                                 "naming conventions, unused variables\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext in ['sql', 'mysql', 'pgsql']:
                        prompt = "Analyze this SQL code diff and find ALL critical issues:\n" + \
                                 "ðŸš¨ SECURITY: SQL injection, privilege escalation, hardcoded credentials, " + \
                                 "data exposure, weak permissions\n" + \
                                 "âš ï¸ QUALITY: Missing indexes, inefficient queries, resource locks, " + \
                                 "transaction handling, performance issues\n" + \
                                 "ðŸ’¡ STYLE: Test comments, deprecated functions, formatting issues\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    else:
                        # Universal analysis for any other file type
                        prompt = "Analyze this code diff and find ALL critical issues across all categories:\n" + \
                                 "ðŸš¨ SECURITY: Hardcoded secrets (passwords, API keys, tokens), " + \
                                 "injection vulnerabilities, insecure functions, weak cryptography\n" + \
                                 "âš ï¸ QUALITY: Memory leaks, resource management, error handling, " + \
                                 "performance issues, infinite loops, null/undefined access\n" + \
                                 "ðŸ’¡ STYLE: Debug statements, test comments, code smells, " + \
                                 "unused variables, formatting issues\n" + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    
                    try:
                        body = json.dumps({
                            "messages": [{"role": "user", "content": [{"text": prompt}]}],
                            "inferenceConfig": {"maxTokens": 1500, "temperature": 0.1}
                        })
                        
                        ai_response = bedrock.invoke_model(
                            modelId="amazon.nova-micro-v1:0",  # CUSTOMIZE: Change AI model here
                            body=body,
                            contentType="application/json"
                        )
                        
                        result = json.loads(ai_response['body'].read())
                        ai_text = result['output']['message']['content'][0]['text']
                        print(f"ðŸ¤– AI response: {ai_text[:150]}...")
                        
                        # Parse diff for line numbers and content
                        lines = patch.split('\n')
                        line_num = 0
                        issues_found = []
                        
                        for line in lines:
                            if line.startswith('@@'):
                                match = re.match(r'@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@', line)
                                if match:
                                    line_num = int(match.group(1)) - 1
                            elif line.startswith('+') and not line.startswith('+++'):
                                line_num += 1
                                line_content = line[1:].strip()
                                
                                # UNIVERSAL SECURITY DETECTION - Works for ALL languages
                                security_keywords = ['password', 'secret', 'token', 'api_key', 'access_key', 
                                                   'private_key', 'secret_key', 'auth_token', 'bearer_token',
                                                   'client_secret', 'app_secret', 'encryption_key']
                                if any(word in line_content.lower() for word in security_keywords):
                                    if '=' in line_content or ':' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security', 
                                            'severity': 'high',
                                            'message': 'Potential hardcoded secret detected',
                                            'suggestion': ''
                                        })
                                
                                # LANGUAGE-SPECIFIC SECURITY AND QUALITY CHECKS
                                
                                # C/C++ specific issues
                                if file_ext in ['c', 'cpp', 'cc', 'cxx', 'h', 'hpp']:
                                    unsafe_c_funcs = {
                                        'gets(': 'fgets(buffer, size, stdin)',
                                        'strcpy(': 'strncpy() or strcpy_s()',
                                        'strcat(': 'strncat() or strcat_s()',
                                        'sprintf(': 'snprintf()',
                                        'scanf(': 'scanf_s() or limit input',
                                        'system(': 'Use safer alternatives',
                                        'exec(': 'Validate input carefully'
                                    }
                                    for func, suggestion in unsafe_c_funcs.items():
                                        if func in line_content:
                                            issues_found.append({
                                                'line': line_num,
                                                'type': 'security',
                                                'severity': 'high',
                                                'message': f'Unsafe C function {func[:-1]}() - buffer overflow/injection risk',
                                                'suggestion': line_content.replace(func[:-1], suggestion.split()[0])
                                            })
                                    
                                    if 'malloc(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'Memory allocation - ensure corresponding free() call',
                                            'suggestion': ''
                                        })
                                
                                # Python specific issues
                                elif file_ext in ['py', 'pyw']:
                                    if 'eval(' in line_content or 'exec(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'eval/exec usage - code injection risk',
                                            'suggestion': ''
                                        })
                                    if 'print(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Consider using logging instead of print statements',
                                            'suggestion': line_content.replace('print(', 'logging.info(')
                                        })
                                    if 'import os' in line_content and 'os.system(' in patch:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'os.system() usage - command injection risk',
                                            'suggestion': 'Use subprocess.run() with shell=False'
                                        })
                                
                                # JavaScript/TypeScript specific issues
                                elif file_ext in ['js', 'jsx', 'ts', 'tsx']:
                                    if 'eval(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'eval() usage - code injection risk',
                                            'suggestion': ''
                                        })
                                    if 'console.log(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Remove console.log in production code',
                                            'suggestion': ''
                                        })
                                    if '==' in line_content and '===' not in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'Use strict equality (===) instead of ==',
                                            'suggestion': line_content.replace('==', '===')
                                        })
                                    if 'innerHTML' in line_content and not 'textContent' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'medium',
                                            'message': 'innerHTML usage - potential XSS vulnerability',
                                            'suggestion': 'Consider using textContent or proper sanitization'
                                        })
                                
                                # Java specific issues
                                elif file_ext in ['java', 'kt', 'scala']:
                                    if 'System.out.print' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Use logging framework instead of System.out',
                                            'suggestion': 'logger.info(...)'
                                        })
                                    if 'Runtime.getRuntime().exec(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'Runtime.exec() - command injection risk',
                                            'suggestion': ''
                                        })
                                
                                # Go specific issues
                                elif file_ext == 'go':
                                    if 'fmt.Print' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Consider using logging instead of fmt.Print',
                                            'suggestion': ''
                                        })
                                    if 'exec.Command(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'medium',
                                            'message': 'Command execution - validate input carefully',
                                            'suggestion': ''
                                        })
                                
                                # C# specific issues
                                elif file_ext == 'cs':
                                    if 'Console.Write' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Use logging framework instead of Console.Write',
                                            'suggestion': ''
                                        })
                                
                                # PHP specific issues
                                elif file_ext == 'php':
                                    if 'eval(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'eval() usage - code injection risk',
                                            'suggestion': ''
                                        })
                                    if 'var_dump(' in line_content or 'print_r(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Remove debug functions in production',
                                            'suggestion': ''
                                        })
                                
                                # Ruby specific issues
                                elif file_ext == 'rb':
                                    if 'eval(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'eval() usage - code injection risk',
                                            'suggestion': ''
                                        })
                                    if 'puts ' in line_content or 'p ' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Consider using logger instead of puts/p',
                                            'suggestion': ''
                                        })
                                
                                # Swift specific issues
                                elif file_ext == 'swift':
                                    if 'print(' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Remove print statements in production',
                                            'suggestion': ''
                                        })
                                    if '!' in line_content and 'Optional' not in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'Force unwrapping detected - consider safe unwrapping',
                                            'suggestion': ''
                                        })
                                
                                # Rust specific issues
                                elif file_ext == 'rs':
                                    if 'unwrap()' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'unwrap() usage - consider proper error handling',
                                            'suggestion': line_content.replace('.unwrap()', '.expect("description")')
                                        })
                                    if 'println!' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Remove println! in production code',
                                            'suggestion': ''
                                        })
                                
                                # UNIVERSAL COMMENT DETECTION (all languages)
                                comment_patterns = [
                                    r'^//\s*(test|debug|hello|todo|fixme|hack)',  # C-style comments
                                    r'^#\s*(test|debug|hello|todo|fixme|hack)',   # Python/Shell comments
                                    r'^\*\s*(test|debug|hello|todo|fixme|hack)',  # Block comment lines
                                    r'^<!--\s*(test|debug|hello|todo|fixme|hack)' # HTML comments
                                ]
                                for pattern in comment_patterns:
                                    if re.match(pattern, line_content.lower()):
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium', 
                                            'message': 'Remove test/debug comment before production',
                                            'suggestion': ''
                                        })
                                
                                # UNIVERSAL SQL INJECTION PATTERNS
                                sql_injection_patterns = [
                                    r'SELECT.*\+.*\+',  # String concatenation in SQL
                                    r'WHERE.*=.*\+',    # Dynamic WHERE clauses
                                    r'INSERT.*\+.*\+',  # Dynamic INSERT
                                    r'UPDATE.*\+.*\+'   # Dynamic UPDATE
                                ]
                                for pattern in sql_injection_patterns:
                                    if re.search(pattern, line_content, re.IGNORECASE):
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security',
                                            'severity': 'high',
                                            'message': 'Potential SQL injection - use parameterized queries',
                                            'suggestion': ''
                                        })
                                
                                # DIVISION BY ZERO CHECK (universal)
                                if '/' in line_content and ('return' in line_content or '=' in line_content):
                                    if 'if' not in line_content and '//' not in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'Division operation without zero check',
                                            'suggestion': ''
                                        })
                                
                                # Check for missing error handling
                                if 'requests.' in line_content and 'except' not in ai_text:
                                    issues_found.append({
                                        'line': line_num,
                                        'type': 'quality',
                                        'severity': 'medium',
                                        'message': 'Consider adding error handling for HTTP requests',
                                        'suggestion': ''
                                    })
                            
                            elif line.startswith(' '):
                                line_num += 1
                        
                        # Create review comments for found issues
                        print(f"ðŸ” Found {len(issues_found)} issues in {filename}")
                        
                        for issue in issues_found:
                            line_num = issue.get('line', 0)
                            severity = issue.get('severity', 'medium')
                            message = issue.get('message', 'Issue detected')
                            suggestion = issue.get('suggestion', '')
                            
                            # Format comment based on severity
                            if severity == 'high':
                                icon = 'ðŸš¨'
                                label = 'Critical'
                            elif severity == 'medium':
                                icon = 'âš ï¸'
                                label = 'Warning'
                            else:
                                icon = 'ðŸ’¡'
                                label = 'Suggestion'
                            
                            comment_body = f"{icon} **{label}:** {message}"
                            
                            # Add suggestion if provided
                            if suggestion:
                                comment_body += f"\n\n```suggestion\n{suggestion}\n```"
                                comment_body += "\n\n*Click 'Commit suggestion' to apply this change automatically.*"
                            elif suggestion == '':
                                comment_body += "\n\n```suggestion\n\n```"
                                comment_body += "\n\n*Click 'Commit suggestion' to remove this line.*"
                            
                            review_comments.append({
                                'path': filename,
                                'line': line_num,
                                'body': comment_body
                            })
                    
                    except Exception as e:
                        print(f"âš ï¸ AI error for {filename}: {e}")
                
                # Post inline comments
                if review_comments:
                    print(f"ðŸ“ Posting {len(review_comments)} inline suggestions...")
                    review_data = {
                        'commit_id': commit_sha,
                        'event': 'COMMENT', 
                        'comments': review_comments
                    }
                    
                    review_response = requests.post(
                        f"https://api.github.com/repos/{repo}/pulls/{pr_number}/reviews",
                        headers=headers,
                        json=review_data
                    )
                    
                    if review_response.status_code == 200:
                        print(f"âœ… Posted {len(review_comments)} inline suggestions")
                    else:
                        print(f"âš ï¸ Failed to post inline comments: {review_response.status_code}")
                        print(f"Response: {review_response.text}")
                        
                        # Fallback: post consolidated comment
                        summary_items = []
                        for comment in review_comments:
                            summary_items.append(f"**{comment['path']}** (line {comment['line']}): {comment['body']}")
                        
                        fallback_comment = "## ðŸ¤– AI Code Review\n\n" + "\n\n---\n\n".join(summary_items)
                        fallback_response = requests.post(
                            f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments",
                            headers=headers,
                            json={'body': fallback_comment}
                        )
                        
                        if fallback_response.status_code == 201:
                            print("âœ… Posted consolidated review comment")
                else:
                    print("â„¹ï¸ No issues found - code looks good!")
            
            print("ðŸŽ‰ Enhanced PR review completed!")
            
        except Exception as e:
            print(f"âŒ Error: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
        EOF