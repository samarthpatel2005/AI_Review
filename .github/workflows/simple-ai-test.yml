name: Enhanced AI PR Review (Copilot Style)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, master, develop ]

env:
  AWS_DEFAULT_REGION: us-east-1

jobs:
  ai-pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install boto3 requests

    - name: Run Enhanced PR Review
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        python3 << 'EOF'
        import os, sys, json, requests, boto3, re
        from datetime import datetime

        print("ðŸ¤– Enhanced AI PR Review (Copilot Style)")
        
        # Get environment
        github_token = os.environ.get('GITHUB_TOKEN')
        repo = os.environ.get('GITHUB_REPOSITORY') 
        pr_number = os.environ.get('PR_NUMBER')
        aws_key = os.environ.get('AWS_ACCESS_KEY_ID')
        aws_secret = os.environ.get('AWS_SECRET_ACCESS_KEY')

        # Initialize Bedrock
        bedrock = None
        try:
            bedrock = boto3.client('bedrock-runtime', region_name='us-east-1', 
                                 aws_access_key_id=aws_key, aws_secret_access_key=aws_secret)
            print("âœ… Bedrock client initialized")
        except Exception as e:
            print(f"âš ï¸ Bedrock error: {e}")

        # GitHub API headers
        headers = {'Authorization': f'token {github_token}', 'Accept': 'application/vnd.github.v3+json'}

        try:
            # Get PR data
            pr_response = requests.get(f"https://api.github.com/repos/{repo}/pulls/{pr_number}", headers=headers)
            pr_response.raise_for_status()
            pr_data = pr_response.json()
            
            files_response = requests.get(f"https://api.github.com/repos/{repo}/pulls/{pr_number}/files", headers=headers)
            files_response.raise_for_status()
            files_data = files_response.json()
            
            print(f"ðŸ“‹ Analyzing PR #{pr_number} with {len(files_data)} files")
            
            # Create PR overview
            title = pr_data.get('title', 'No title')
            total_files = len(files_data)
            total_additions = sum(f.get('additions', 0) for f in files_data)
            total_deletions = sum(f.get('deletions', 0) for f in files_data)
            
            overview_parts = [
                "## Pull Request Overview",
                "",
                f"This PR modifies {total_files} file{'s' if total_files != 1 else ''} with {total_additions} additions and {total_deletions} deletions.",
                "",
                f"**{title}**",
                "",
                "### Changes Summary"
            ]
            
            # Add file changes
            for file_data in files_data:
                filename = file_data.get('filename', '')
                additions = file_data.get('additions', 0)
                deletions = file_data.get('deletions', 0)
                status = file_data.get('status', '')
                
                if status == 'added':
                    overview_parts.append(f"â€¢ **Added** `{filename}` ({additions} lines)")
                elif status == 'modified':
                    overview_parts.append(f"â€¢ **Modified** `{filename}` (+{additions}/-{deletions})")
                else:
                    overview_parts.append(f"â€¢ **Changed** `{filename}`")
            
            # Add code diff
            overview_parts.extend(["", "### Code Changes"])
            for file_data in files_data:
                filename = file_data.get('filename', '')
                patch = file_data.get('patch', '')
                if patch:
                    overview_parts.extend([f"", f"**{filename}**", "```diff"])
                    for line in patch.split('\n'):
                        if not line.startswith('@@') and not line.startswith('+++') and not line.startswith('---'):
                            if line.startswith(('+', '-', ' ')):
                                overview_parts.append(line)
                    overview_parts.append("```")
            
            # Add Copilot tip
            overview_parts.extend([
                "",
                "---", 
                "**Tip:** Customize your code reviews with copilot-instructions.md. [Create the file](https://github.com/github/copilot-instructions) or [learn how to get started](https://docs.github.com/en/copilot)."
            ])
            
            # Post overview
            overview_text = "\n".join(overview_parts)
            comment_response = requests.post(
                f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments",
                headers=headers,
                json={'body': overview_text}
            )
            
            if comment_response.status_code == 201:
                print("âœ… Posted PR overview")
            else:
                print(f"âš ï¸ Failed to post overview: {comment_response.status_code}")
            
            # Enhanced AI Analysis for ALL issues and file types
            if bedrock:
                commit_sha = pr_data['head']['sha']
                review_comments = []
                
                for file_data in files_data:
                    filename = file_data.get('filename', '')
                    patch = file_data.get('patch', '')
                    status = file_data.get('status', '')
                    
                    # Skip binary files
                    skip_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.zip', '.exe', '.dll']
                    if not patch or any(filename.lower().endswith(ext) for ext in skip_extensions):
                        continue
                    
                    print(f"ðŸ” AI analyzing {filename} (status: {status})...")
                    
                    # Enhanced AI prompt for ALL issues
                    file_ext = filename.split('.')[-1].lower() if '.' in filename else ''
                    
                    if file_ext in ['c', 'cpp', 'h']:
                        prompt = "Analyze this C/C++ code diff and find critical security and quality issues. " + \
                                 "Look for: hardcoded secrets, buffer overflows (gets, strcpy, strcat, sprintf), " + \
                                 "memory leaks (malloc without free), uninitialized variables, division by zero, " + \
                                 "SQL injection risks, test/debug comments. " + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    elif file_ext == 'py':
                        prompt = "Analyze this Python code diff and find critical issues. " + \
                                 "Look for: hardcoded secrets, security vulnerabilities, test comments, " + \
                                 "debug prints, unused imports, missing error handling, type hints. " + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    else:
                        prompt = "Analyze this code diff and find critical issues. " + \
                                 "Look for: hardcoded secrets, security issues, test comments, " + \
                                 "debug code, unused imports, missing error handling. " + \
                                 f"FILE: {filename} STATUS: {status} DIFF: {patch}"
                    
                    try:
                        body = json.dumps({
                            "messages": [{"role": "user", "content": [{"text": prompt}]}],
                            "inferenceConfig": {"maxTokens": 1500, "temperature": 0.1}
                        })
                        
                        ai_response = bedrock.invoke_model(
                            modelId="amazon.nova-micro-v1:0",
                            body=body,
                            contentType="application/json"
                        )
                        
                        result = json.loads(ai_response['body'].read())
                        ai_text = result['output']['message']['content'][0]['text']
                        print(f"ðŸ¤– AI response: {ai_text[:150]}...")
                        
                        # Parse diff for line numbers and content
                        lines = patch.split('\n')
                        line_num = 0
                        issues_found = []
                        
                        for line in lines:
                            if line.startswith('@@'):
                                match = re.match(r'@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@', line)
                                if match:
                                    line_num = int(match.group(1)) - 1
                            elif line.startswith('+') and not line.startswith('+++'):
                                line_num += 1
                                line_content = line[1:].strip()
                                
                                # Check for security issues - hardcoded secrets
                                security_keywords = ['password', 'secret', 'token', 'api_key', 'access_key']
                                if any(word in line_content.lower() for word in security_keywords):
                                    if '=' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'security', 
                                            'severity': 'high',
                                            'message': 'Potential hardcoded secret detected',
                                            'suggestion': ''
                                        })
                                
                                # C-specific security issues
                                if filename.endswith(('.c', '.cpp', '.h')):
                                    # Unsafe C functions
                                    unsafe_c_funcs = ['gets(', 'strcpy(', 'strcat(', 'sprintf(', 'scanf(']
                                    for func in unsafe_c_funcs:
                                        if func in line_content:
                                            safe_alternatives = {
                                                'gets(': 'fgets(buffer, size, stdin)',
                                                'strcpy(': 'strncpy() or strcpy_s()',
                                                'strcat(': 'strncat() or strcat_s()',
                                                'sprintf(': 'snprintf()',
                                                'scanf(': 'scanf_s() or limit with %Ns'
                                            }
                                            issues_found.append({
                                                'line': line_num,
                                                'type': 'security',
                                                'severity': 'high',
                                                'message': f'Unsafe C function {func[:-1]}() detected - buffer overflow risk',
                                                'suggestion': line_content.replace(func[:-1], safe_alternatives[func].split()[0])
                                            })
                                    
                                    # Memory management issues
                                    if 'malloc(' in line_content and 'free(' not in ai_text:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'high',
                                            'message': 'Potential memory leak - malloc without corresponding free',
                                            'suggestion': ''
                                        })
                                    
                                    # Division without zero check
                                    if '/' in line_content and 'if' not in line_content and 'return' in line_content:
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium',
                                            'message': 'Division operation without zero check',
                                            'suggestion': ''
                                        })
                                
                                # Check for test/debug comments (C and other languages)
                                comment_patterns = [r'^//\s*(test|debug|hello|todo|fixme)', r'^#\s*(test|debug|hello|todo|fixme)']
                                for pattern in comment_patterns:
                                    if re.match(pattern, line_content.lower()):
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'medium', 
                                            'message': 'Remove test/debug comment before production',
                                            'suggestion': ''
                                        })
                                
                                # Check for print statements in Python
                                if 'print(' in line_content and filename.endswith('.py'):
                                    issues_found.append({
                                        'line': line_num,
                                        'type': 'quality',
                                        'severity': 'low',
                                        'message': 'Consider using logging instead of print statements',
                                        'suggestion': line_content.replace('print(', 'logging.info(')
                                    })
                                
                                # Check for printf in C (could suggest logging)
                                if 'printf(' in line_content and filename.endswith(('.c', '.cpp')):
                                    if 'debug' in line_content.lower() or 'test' in line_content.lower():
                                        issues_found.append({
                                            'line': line_num,
                                            'type': 'quality',
                                            'severity': 'low',
                                            'message': 'Consider removing debug printf statements',
                                            'suggestion': ''
                                        })
                                
                                # Check for missing error handling
                                if 'requests.' in line_content and 'except' not in ai_text:
                                    issues_found.append({
                                        'line': line_num,
                                        'type': 'quality',
                                        'severity': 'medium',
                                        'message': 'Consider adding error handling for HTTP requests',
                                        'suggestion': ''
                                    })
                            
                            elif line.startswith(' '):
                                line_num += 1
                        
                        # Create review comments for found issues
                        print(f"ðŸ” Found {len(issues_found)} issues in {filename}")
                        
                        for issue in issues_found:
                            line_num = issue.get('line', 0)
                            severity = issue.get('severity', 'medium')
                            message = issue.get('message', 'Issue detected')
                            suggestion = issue.get('suggestion', '')
                            
                            # Format comment based on severity
                            if severity == 'high':
                                icon = 'ðŸš¨'
                                label = 'Critical'
                            elif severity == 'medium':
                                icon = 'âš ï¸'
                                label = 'Warning'
                            else:
                                icon = 'ðŸ’¡'
                                label = 'Suggestion'
                            
                            comment_body = f"{icon} **{label}:** {message}"
                            
                            # Add suggestion if provided
                            if suggestion:
                                comment_body += f"\n\n```suggestion\n{suggestion}\n```"
                                comment_body += "\n\n*Click 'Commit suggestion' to apply this change automatically.*"
                            elif suggestion == '':
                                comment_body += "\n\n```suggestion\n\n```"
                                comment_body += "\n\n*Click 'Commit suggestion' to remove this line.*"
                            
                            review_comments.append({
                                'path': filename,
                                'line': line_num,
                                'body': comment_body
                            })
                    
                    except Exception as e:
                        print(f"âš ï¸ AI error for {filename}: {e}")
                
                # Post inline comments
                if review_comments:
                    print(f"ðŸ“ Posting {len(review_comments)} inline suggestions...")
                    review_data = {
                        'commit_id': commit_sha,
                        'event': 'COMMENT', 
                        'comments': review_comments
                    }
                    
                    review_response = requests.post(
                        f"https://api.github.com/repos/{repo}/pulls/{pr_number}/reviews",
                        headers=headers,
                        json=review_data
                    )
                    
                    if review_response.status_code == 200:
                        print(f"âœ… Posted {len(review_comments)} inline suggestions")
                    else:
                        print(f"âš ï¸ Failed to post inline comments: {review_response.status_code}")
                        print(f"Response: {review_response.text}")
                        
                        # Fallback: post consolidated comment
                        summary_items = []
                        for comment in review_comments:
                            summary_items.append(f"**{comment['path']}** (line {comment['line']}): {comment['body']}")
                        
                        fallback_comment = "## ðŸ¤– AI Code Review\n\n" + "\n\n---\n\n".join(summary_items)
                        fallback_response = requests.post(
                            f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments",
                            headers=headers,
                            json={'body': fallback_comment}
                        )
                        
                        if fallback_response.status_code == 201:
                            print("âœ… Posted consolidated review comment")
                else:
                    print("â„¹ï¸ No issues found - code looks good!")
            
            print("ðŸŽ‰ Enhanced PR review completed!")
            
        except Exception as e:
            print(f"âŒ Error: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
        EOF